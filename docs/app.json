[{"name":"app.R","content":"library(shiny)\n\n# --- UI ---\nui <- fluidPage(\n  titlePanel(\"Window length influence on stress score\"),\n  \n  sidebarLayout(\n    sidebarPanel(\n      tabsetPanel(\n        tabPanel(\"Parameters\",\n          br(),\n          numericInput(\"samples\", \"Total months modeled\", value = 2000, min = 100, step = 100),\n          sliderInput(\"gap\", \"Withdrawal signal (gap)\", min = 0, max = 10, value = 0.5, step = 0.5),\n          sliderInput(\"noise\", \"Noise magnitude (sigma)\", min = 1, max = 30, value = 15),\n          sliderInput(\"trend\", \"Annual trend (gain/loss)\", min = -0.5, max = 0.5, value = 0.0, step = 0.05)\n        ),\n        tabPanel(\"Distributions\",\n          br(),\n          selectInput(\"dist_type\", \"Noise distribution\",\n                      choices = c(\"Normal\" = \"norm\", \"Log-Normal\" = \"lnorm\", \"Weibull\" = \"weibull\"),\n                      selected = \"lnorm\"),\n          checkboxInput(\"detrend\", \"Remove trend\", value = FALSE)\n        )\n      ),\n      hr(),\n      selectInput(\"window\", \"Rolling window (years)\", choices = c(5, 10, 20, 30), selected = 5),\n      \n      actionButton(\"save_shadow\", \"Ghost current view\", icon = icon(\"ghost\"), class = \"btn-info\"),\n      actionButton(\"clear_shadow\", \"Clear ghosts\", icon = icon(\"trash\"))\n    ),\n    \n    mainPanel(\n      plotOutput(\"timePlot\", height = \"300px\"),\n      plotOutput(\"distPlot\", height = \"500px\")\n    )\n  )\n)\n\n# --- Server ---\nserver <- function(input, output, session) {\n  \n  # Store Ghost Data\n  v <- reactiveValues(\n    shadow_dens_nat = NULL,\n    shadow_dens_post = NULL,\n    shadow_metrics = NULL,\n    shadow_win = NULL\n  )\n  \n  # 1. Custom rolling mean function (replaces 'zoo' package)\n  manual_roll <- function(x, k) {\n    # stats::filter computes moving averages. sides=1 means \"past values\" (align right)\n    as.numeric(stats::filter(x, rep(1/k, k), sides = 1))\n  }\n  \n  # 2. Data Generation\n  data_gen <- reactive({\n    set.seed(42)\n    n <- input$samples\n    t <- 1:n\n    \n    # Generate noise\n    noise_raw <- switch(input$dist_type,\n      \"norm\"    = rnorm(n, 0, input$noise),\n      \"lnorm\"   = { \n        d <- rlnorm(n, 0, 0.5)\n        (d - mean(d)) * (input$noise / sd(d)) \n      },\n      \"weibull\" = { \n        d <- rweibull(n, 1.5, 1)\n        (d - mean(d)) * (input$noise / sd(d)) \n      }\n    )\n    \n    # Trend logic\n    current_trend <- if(input$detrend) 0 else input$trend\n    natural <- 60 + (current_trend * t) + noise_raw\n    post <- natural - input$gap\n    \n    # Return as list (lighter than data.frame)\n    list(Month = t, Natural = natural, Post = post)\n  })\n  \n  # 3. Process rolling means\n  processed <- reactive({\n    d <- data_gen()\n    w_months <- as.numeric(input$window) * 12\n    \n    # Apply rolling mean\n    nat_roll <- manual_roll(d$Natural, w_months)\n    post_roll <- manual_roll(d$Post, w_months)\n    \n    # Remove NAs created by the filter\n    valid_idx <- !is.na(nat_roll)\n    \n    list(\n      Month = d$Month[valid_idx],\n      Natural = d$Natural[valid_idx], # Keep raw for background\n      Post = d$Post[valid_idx],\n      Nat_Roll = nat_roll[valid_idx],\n      Post_Roll = post_roll[valid_idx]\n    )\n  })\n\n  # 4. Metric calculation (overlap & stress)\n  calc_metrics <- function(nat, post) {\n    # Compute densities on a common grid to calculate intersection area\n    x_range <- range(c(nat, post))\n    # Extend range slightly to prevent cutoff\n    from <- x_range[1] - 10\n    to <- x_range[2] + 10\n    \n    d1 <- density(nat, from = from, to = to, n = 512)\n    d2 <- density(post, from = from, to = to, n = 512)\n    \n    # Overlap is the intersection of the two curves\n    # Area = sum(min(y1, y2)) * dx\n    dx <- d1$x[2] - d1$x[1]\n    overlap_area <- sum(pmin(d1$y, d2$y)) * dx\n    \n    # Stress direction (median shift)\n    direction <- if(median(post) < median(nat)) -1 else 1\n    stress <- (1 - overlap_area) * direction\n    \n    list(\n      overlap = round(overlap_area, 1),\n      stress = round(stress, 1)\n    )\n  }\n\n  # 5. Ghosting logic\n  observeEvent(input$save_shadow, {\n    d <- processed()\n    metrics <- calc_metrics(d$Nat_Roll, d$Post_Roll)\n    \n    # Store the density objects directly\n    v$shadow_dens_nat <- density(d$Nat_Roll)\n    v$shadow_dens_post <- density(d$Post_Roll)\n    v$shadow_metrics <- metrics\n    v$shadow_win <- input$window\n  })\n  \n  observeEvent(input$clear_shadow, {\n    v$shadow_dens_nat <- NULL\n    v$shadow_dens_post <- NULL\n    v$shadow_metrics <- NULL\n    v$shadow_win <- NULL\n  })\n\n  # 6. Base R time plot\n  output$timePlot <- renderPlot({\n    d <- processed()\n    \n    # Setup canvas\n    par(mar = c(4, 4, 2, 1))\n    plot(d$Month, d$Natural, type = \"n\", \n         ylim = range(c(d$Natural, d$Post), na.rm=TRUE),\n         ylab = \"Flow volume\", xlab = \"Month\",\n         main = \"Rolling mean vs. raw values\")\n    \n    # Raw noise (faint)\n    lines(d$Month, d$Natural, col = adjustcolor(\"blue\", alpha.f = 0.15))\n    lines(d$Month, d$Post, col = adjustcolor(\"orange\", alpha.f = 0.15))\n    \n    # Rolling signal (solid)\n    lines(d$Month, d$Nat_Roll, col = \"blue\", lwd = 2)\n    lines(d$Month, d$Post_Roll, col = \"orange\", lwd = 2)\n    \n    legend(\"topleft\", legend = c(\"Baseline\", \"Post-withdrawal\"), \n           col = c(\"blue\", \"orange\"), lwd = 2, bty = \"n\")\n  })\n\n  # 7. Base R distribution plot\n  output$distPlot <- renderPlot({\n    d <- processed()\n    \n    # Calculate current densities\n    d_nat <- density(d$Nat_Roll)\n    d_post <- density(d$Post_Roll)\n    \n    # Compute combined \"System Profile\" (Average of the two densities)\n    # We need to approximate d_post onto d_nat's grid to add them\n    d_post_interp <- approx(d_post$x, d_post$y, xout = d_nat$x, rule = 2)$y\n    system_y <- (d_nat$y + d_post_interp) / 2\n    \n    # Determine Plot Limits (Include Ghost if present)\n    y_max <- max(d_nat$y, d_post$y, system_y)\n    x_lims <- range(c(d_nat$x, d_post$x))\n    \n    if(!is.null(v$shadow_dens_nat)) {\n      y_max <- max(y_max, v$shadow_dens_nat$y, v$shadow_dens_post$y)\n      x_lims <- range(c(x_lims, v$shadow_dens_nat$x))\n    }\n    \n    # Setup canvas\n    par(mar = c(5, 4, 4, 2) + 0.1)\n    plot(NA, xlim = x_lims, ylim = c(0, y_max * 1.1), \n         xlab = \"Volume\", ylab = \"Density\", main = \"\", axes = FALSE)\n    axis(1); axis(2); box()\n    title(main = \"Distribution overlap\", font.main = 1)\n    \n    # --- Draw ghost (if exists) ---\n    if(!is.null(v$shadow_dens_nat)) {\n      lines(v$shadow_dens_nat, col = \"blue\", lty = 2, lwd = 1)\n      lines(v$shadow_dens_post, col = \"orange\", lty = 2, lwd = 1)\n    }\n    \n    # --- Draw current ---\n    # Filled areas\n    polygon(d_nat, col = adjustcolor(\"blue\", alpha.f = 0.2), border = \"blue\")\n    polygon(d_post, col = adjustcolor(\"orange\", alpha.f = 0.2), border = \"orange\")\n    \n    # System profile line (black)\n    #lines(d_nat$x, system_y, col = \"black\", lwd = 2.5)\n    \n    # --- Annotations (in box) ---\n    curr_metrics <- calc_metrics(d$Nat_Roll, d$Post_Roll)\n    \n    # Text construction\n    txt_curr <- paste0(\"Current (\", input$window, \"yr):\\n\",\n                       \"  Overlap: \", curr_metrics$overlap, \"\\n\",\n                       \"  Stress:  \", curr_metrics$stress)\n    \n    txt_final <- txt_curr\n    if(!is.null(v$shadow_win)) {\n      txt_ghost <- paste0(\"\\n\\nGhost (\", v$shadow_win, \"yr):\\n\",\n                          \"  Overlap: \", v$shadow_metrics$overlap, \"\\n\",\n                          \"  Stress:  \", v$shadow_metrics$stress)\n      txt_final <- paste0(txt_curr, txt_ghost)\n    }\n    \n    legend(\"topright\", legend = strsplit(txt_final, \"\\n\")[[1]], \n           bty = \"o\", bg = \"white\", cex = 1.0, adj = 0)\n    \n    legend(\"topleft\", legend = c(\"Baseline\", \"Post-withdrawal\", \"Ghost (previous)\"),\n           fill = c(adjustcolor(\"blue\", 0.2), adjustcolor(\"orange\", 0.2), NA, NA),\n           border = c(\"blue\", \"orange\", NA, NA),\n           lwd = c(NA, NA, 1), lty = c(NA, NA, 2), col = c(NA, NA, \"black\"),\n           bty = \"n\")\n  })\n}\n\nshinyApp(ui, server)","type":"text"}]
